apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: build-multiarch-base-image
spec:
  params:
  - name: package
    description: package to build (e.g. github.com/<org>/<project>)
    default: github.com/tektoncd/pipeline
  - name: imageRegistry
    description: The target image registry
  - name: imageRegistryPath
    description: The path (project) in the container registry
  - name: platforms
    description: Platforms to publish for the images (e.g. linux/amd64,linux/arm64)
    default: linux/amd64,linux/arm,linux/arm64,linux/s390x,linux/ppc64le
  - name: serviceAccountPath
    description: The name of the service account path within the release-secret workspace
  workspaces:
    - name: source
      description: The workspace where the repo has been cloned
    - name: release-secret
      description: The secret that contains a service account authorized to push to the imageRegistry and to the output bucket
  steps:

  - image: gcr.io/tekton-releases/dogfooding/buildx-gcloud:latest
    name: build-image
    env:
    # Connect to the sidecar over TCP, with TLS.
    - name: DOCKER_HOST
      value: tcp://localhost:2376
    # Verify TLS.
    - name: DOCKER_TLS_VERIFY
      value: '1'
    # Use the certs generated by the sidecar daemon.
    - name: DOCKER_CERT_PATH
      value: /certs/client
    - name: PACKAGE
      value: $(params.package)
    - name: IMAGE_REGISTRY
      value: $(params.imageRegistry)
    - name: IMAGE_REGISTRY_PATH
      value: $(params.imageRegistryPath)
    - name: PLATFORMS
      value: $(params.platforms)
    - name: SERVICE_ACCOUNT_PATH
      value: $(params.serviceAccountPath)
    script: |
      #!/usr/bin/env sh
      set -ex

      # Activate service account
      gcloud auth activate-service-account --key-file=$(workspaces.release-secret.path)/${SERVICE_ACCOUNT_PATH}
      # Setup docker-auth
      gcloud auth configure-docker

      ln -s /root/.docker/cli-plugins ~/.docker/cli-plugins

      # add qemu bins
      docker run --rm --privileged tonistiigi/binfmt:latest --install all

      #create docker context
      docker context create context1

      #create builder
      docker buildx create context1 --name builder-buildx1 --driver docker-container --platform "${PLATFORMS}" --use

      #check the state
      docker buildx inspect --bootstrap --builder builder-buildx1

      #build multi-arch git-init build-base image
      docker buildx build \
        --platform "${PLATFORMS}" \
        --tag ${IMAGE_REGISTRY}/${IMAGE_REGISTRY_PATH}/${PACKAGE}/git-init-build-base \
        --push \
        --no-cache \
        $(workspaces.source.path)/images/git-init

      #build multi-arch pullrequest-init build-base image
      docker buildx build \
        --platform "${PLATFORMS}" \
        --tag ${IMAGE_REGISTRY}/${IMAGE_REGISTRY_PATH}/${PACKAGE}/pullrequest-init-build-base \
        --push \
        --no-cache \
        $(workspaces.source.path)/images/pullrequest-init

    volumeMounts:
    - mountPath: /certs/client
      name: dind-certs

  sidecars:
  - image: docker:dind
    name: server
    args:
      - --storage-driver=vfs
      - --userland-proxy=false
      - --debug
    securityContext:
      privileged: true
    env:
    # Write generated certs to the path shared with the client.
    - name: DOCKER_TLS_CERTDIR
      value: /certs
    volumeMounts:
    - mountPath: /certs/client
      name: dind-certs
    # Wait for the dind daemon to generate the certs it will share with the
    # client.
    readinessProbe:
      periodSeconds: 1
      exec:
        command: ['ls', '/certs/client/ca.pem']

  volumes:
  - name: dind-certs
    emptyDir: {}
