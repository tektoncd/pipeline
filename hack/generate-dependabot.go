// Copyright 2025 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//go:build tools

package main

import (
	"fmt"
	"os"
	"path/filepath"

	"gopkg.in/yaml.v3"
)

// Config represents the dependabot configuration file structure
type Config struct {
	ReleaseBranches []string    `yaml:"release-branches"`
	Ecosystems      []Ecosystem `yaml:"ecosystems"`
}

// Ecosystem represents a package ecosystem configuration
type Ecosystem struct {
	PackageEcosystem string                   `yaml:"package-ecosystem"`
	Directory        string                   `yaml:"directory"`
	Schedule         map[string]interface{}   `yaml:"schedule"`
	Labels           []string                 `yaml:"labels"`
	Ignore           []map[string]interface{} `yaml:"ignore,omitempty"`
	Groups           map[string]interface{}   `yaml:"groups,omitempty"`
}

// DependabotConfig represents the generated dependabot.yml structure
type DependabotConfig struct {
	Version int      `yaml:"version"`
	Updates []Update `yaml:"updates"`
}

// Update represents a single dependabot update configuration
type Update struct {
	PackageEcosystem string                   `yaml:"package-ecosystem"`
	Directory        string                   `yaml:"directory"`
	TargetBranch     string                   `yaml:"target-branch,omitempty"`
	Schedule         map[string]interface{}   `yaml:"schedule"`
	Labels           []string                 `yaml:"labels"`
	Ignore           []map[string]interface{} `yaml:"ignore,omitempty"`
	Groups           map[string]interface{}   `yaml:"groups,omitempty"`
}

func main() {
	if err := run(); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

func run() error {
	configPath := filepath.Join(".github", "dependabot.config.yml")
	outputPath := filepath.Join(".github", "dependabot.yml")

	configData, err := os.ReadFile(configPath)
	if err != nil {
		return fmt.Errorf("failed to read config file: %w", err)
	}

	var config Config
	if err := yaml.Unmarshal(configData, &config); err != nil {
		return fmt.Errorf("failed to parse config file: %w", err)
	}

	fmt.Printf("Loading configuration from %s\n", configPath)
	fmt.Printf("  - Found %d ecosystem(s)\n", len(config.Ecosystems))
	fmt.Printf("  - Found %d release branch(es)", len(config.ReleaseBranches))
	if len(config.ReleaseBranches) > 0 {
		fmt.Printf(": %v", config.ReleaseBranches)
	}
	fmt.Println()

	// Generate dependabot config
	dependabotConfig := generateDependabotConfig(config)

	// Write output with header
	header := `# Generated file - DO NOT EDIT MANUALLY
# This file is generated by hack/generate-dependabot.sh
#
# To update this file:
# 1. Edit .github/dependabot.config.yml
# 2. Run: ./hack/generate-dependabot.sh
#
`

	output, err := yaml.Marshal(&dependabotConfig)
	if err != nil {
		return fmt.Errorf("failed to marshal output: %w", err)
	}

	fullOutput := header + string(output)
	if err := os.WriteFile(outputPath, []byte(fullOutput), 0644); err != nil {
		return fmt.Errorf("failed to write output file: %w", err)
	}

	fmt.Printf("\nâœ“ Generated %s\n", outputPath)
	fmt.Printf("  - Main branch: %d ecosystems\n", len(config.Ecosystems))
	fmt.Printf("  - Release branches: %d branches\n", len(config.ReleaseBranches))
	fmt.Printf("  - Total update entries: %d\n", len(dependabotConfig.Updates))

	return nil
}

func generateDependabotConfig(config Config) DependabotConfig {
	dependabotConfig := DependabotConfig{
		Version: 2,
		Updates: []Update{},
	}

	// Add entries for main branch (no target-branch, uses existing ignore rules)
	for _, ecosystem := range config.Ecosystems {
		update := Update{
			PackageEcosystem: ecosystem.PackageEcosystem,
			Directory:        ecosystem.Directory,
			Schedule:         ecosystem.Schedule,
			Labels:           ecosystem.Labels,
			Ignore:           ecosystem.Ignore,
			Groups:           ecosystem.Groups,
		}
		dependabotConfig.Updates = append(dependabotConfig.Updates, update)
	}

	// Add entries for each release branch (with target-branch and patch-only)
	for _, branch := range config.ReleaseBranches {
		for _, ecosystem := range config.Ecosystems {
			// Copy ignore rules from template
			ignore := make([]map[string]interface{}, len(ecosystem.Ignore))
			copy(ignore, ecosystem.Ignore)

			// Add patch-only restriction for release branches
			ignore = append(ignore, map[string]interface{}{
				"dependency-name": "*",
				"update-types": []string{
					"version-update:semver-major",
					"version-update:semver-minor",
				},
			})

			update := Update{
				PackageEcosystem: ecosystem.PackageEcosystem,
				Directory:        ecosystem.Directory,
				TargetBranch:     branch,
				Schedule:         ecosystem.Schedule,
				Labels:           ecosystem.Labels,
				Ignore:           ignore,
				Groups:           ecosystem.Groups,
			}
			dependabotConfig.Updates = append(dependabotConfig.Updates, update)
		}
	}

	return dependabotConfig
}
