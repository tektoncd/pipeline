{
  "swagger": "2.0",
  "info": {
    "description": "Tekton Pipeline",
    "title": "Tekton",
    "version": "v0.17.2"
  },
  "paths": {},
  "definitions": {
    "pod.AffinityAssistantTemplate": {
      "description": "AffinityAssistantTemplate holds pod specific configuration and is a subset of the generic pod Template",
      "type": "object",
      "properties": {
        "imagePullSecrets": {
          "description": "ImagePullSecrets gives the name of the secret used by the pod to pull the image if specified",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.LocalObjectReference"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "nodeSelector": {
          "description": "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "tolerations": {
          "description": "If specified, the pod's tolerations.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Toleration"
          },
          "x-kubernetes-list-type": "atomic"
        }
      }
    },
    "pod.Template": {
      "description": "Template holds pod specific configuration",
      "type": "object",
      "properties": {
        "affinity": {
          "description": "If specified, the pod's scheduling constraints",
          "$ref": "#/definitions/v1.Affinity"
        },
        "automountServiceAccountToken": {
          "description": "AutomountServiceAccountToken indicates whether pods running as this service account should have an API token automatically mounted.",
          "type": "boolean"
        },
        "dnsConfig": {
          "description": "Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.",
          "$ref": "#/definitions/v1.PodDNSConfig"
        },
        "dnsPolicy": {
          "description": "Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.",
          "type": "string"
        },
        "enableServiceLinks": {
          "description": "EnableServiceLinks indicates whether information about services should be injected into pod's environment variables, matching the syntax of Docker links. Optional: Defaults to true.",
          "type": "boolean"
        },
        "hostAliases": {
          "description": "HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified. This is only valid for non-hostNetwork pods.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.HostAlias"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "hostNetwork": {
          "description": "HostNetwork specifies whether the pod may use the node network namespace",
          "type": "boolean"
        },
        "imagePullSecrets": {
          "description": "ImagePullSecrets gives the name of the secret used by the pod to pull the image if specified",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.LocalObjectReference"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "nodeSelector": {
          "description": "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "priorityClassName": {
          "description": "If specified, indicates the pod's priority. \"system-node-critical\" and \"system-cluster-critical\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.",
          "type": "string"
        },
        "runtimeClassName": {
          "description": "RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod. If no RuntimeClass resource matches the named class, the pod will not be run. If unset or empty, the \"legacy\" RuntimeClass will be used, which is an implicit class with an empty definition that uses the default runtime handler. More info: https://git.k8s.io/enhancements/keps/sig-node/runtime-class.md This is a beta feature as of Kubernetes v1.14.",
          "type": "string"
        },
        "schedulerName": {
          "description": "SchedulerName specifies the scheduler to be used to dispatch the Pod",
          "type": "string"
        },
        "securityContext": {
          "description": "SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.",
          "$ref": "#/definitions/v1.PodSecurityContext"
        },
        "tolerations": {
          "description": "If specified, the pod's tolerations.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Toleration"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "volumes": {
          "description": "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Volume"
          },
          "x-kubernetes-list-type": "atomic",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge,retainKeys"
        }
      }
    },
    "v1.ArrayOrString": {
      "description": "ArrayOrString is a type that can hold a single string or string array. Used in JSON unmarshalling so that a single JSON field can accept either an individual string or an array of strings. consideration the object case after the community reaches an agreement on it.",
      "type": "object",
      "required": [
        "type",
        "stringVal",
        "arrayVal",
        "objectVal"
      ],
      "properties": {
        "arrayVal": {
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "objectVal": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "stringVal": {
          "description": "Represents the stored type of ArrayOrString.",
          "type": "string",
          "default": ""
        },
        "type": {
          "type": "string",
          "default": ""
        }
      }
    },
    "v1.Param": {
      "description": "Param declares an ArrayOrString to use for the parameter called name.",
      "type": "object",
      "required": [
        "name",
        "value"
      ],
      "properties": {
        "name": {
          "type": "string",
          "default": ""
        },
        "value": {
          "default": {},
          "$ref": "#/definitions/v1.ArrayOrString"
        }
      }
    },
    "v1.ParamSpec": {
      "description": "ParamSpec defines arbitrary parameters needed beyond typed inputs (such as resources). Parameter values are provided by users as inputs on a TaskRun or PipelineRun.",
      "type": "object",
      "required": [
        "name"
      ],
      "properties": {
        "default": {
          "description": "Default is the value a parameter takes if no input value is supplied. If default is set, a Task may be executed without a supplied value for the parameter.",
          "$ref": "#/definitions/v1.ArrayOrString"
        },
        "description": {
          "description": "Description is a user-facing description of the parameter that may be used to populate a UI.",
          "type": "string"
        },
        "name": {
          "description": "Name declares the name by which a parameter is referenced.",
          "type": "string",
          "default": ""
        },
        "properties": {
          "description": "Properties is the JSON Schema properties to support key-value pairs parameter.",
          "type": "object",
          "additionalProperties": {
            "default": {},
            "$ref": "#/definitions/v1.PropertySpec"
          }
        },
        "type": {
          "description": "Type is the user-specified type of the parameter. The possible types are currently \"string\", \"array\" and \"object\", and \"string\" is the default.",
          "type": "string"
        }
      }
    },
    "v1.PipelineWorkspaceDeclaration": {
      "description": "WorkspacePipelineDeclaration creates a named slot in a Pipeline that a PipelineRun is expected to populate with a workspace binding. Deprecated: use PipelineWorkspaceDeclaration type instead",
      "type": "object",
      "required": [
        "name"
      ],
      "properties": {
        "description": {
          "description": "Description is a human readable string describing how the workspace will be used in the Pipeline. It can be useful to include a bit of detail about which tasks are intended to have access to the data on the workspace.",
          "type": "string"
        },
        "name": {
          "description": "Name is the name of a workspace to be provided by a PipelineRun.",
          "type": "string",
          "default": ""
        },
        "optional": {
          "description": "Optional marks a Workspace as not being required in PipelineRuns. By default this field is false and so declared workspaces are required.",
          "type": "boolean"
        }
      }
    },
    "v1.PropertySpec": {
      "description": "PropertySpec defines the struct for object keys",
      "type": "object",
      "properties": {
        "type": {
          "type": "string"
        }
      }
    },
    "v1.ResolverParam": {
      "description": "ResolverParam is a single parameter passed to a resolver.",
      "type": "object",
      "required": [
        "name",
        "value"
      ],
      "properties": {
        "name": {
          "description": "Name is the name of the parameter that will be passed to the resolver.",
          "type": "string",
          "default": ""
        },
        "value": {
          "description": "Value is the string value of the parameter that will be passed to the resolver.",
          "type": "string",
          "default": ""
        }
      }
    },
    "v1.ResolverRef": {
      "description": "ResolverRef can be used to refer to a Pipeline or Task in a remote location like a git repo. This feature is in alpha and these fields are only available when the alpha feature gate is enabled.",
      "type": "object",
      "properties": {
        "resolver": {
          "description": "Resolver is the name of the resolver that should perform resolution of the referenced Tekton resource, such as \"git\".",
          "type": "string"
        },
        "resource": {
          "description": "Resource contains the parameters used to identify the referenced Tekton resource. Example entries might include \"repo\" or \"path\" but the set of params ultimately depends on the chosen resolver.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.ResolverParam"
          },
          "x-kubernetes-list-type": "atomic"
        }
      }
    },
    "v1.Sidecar": {
      "description": "Sidecar has nearly the same data structure as Step but does not have the ability to timeout.",
      "type": "object",
      "required": [
        "name"
      ],
      "properties": {
        "args": {
          "description": "Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "command": {
          "description": "Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "env": {
          "description": "List of environment variables to set in the container. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.EnvVar"
          },
          "x-kubernetes-list-type": "atomic",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "envFrom": {
          "description": "List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.EnvFromSource"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "image": {
          "description": "Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.",
          "type": "string"
        },
        "imagePullPolicy": {
          "description": "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images",
          "type": "string"
        },
        "lifecycle": {
          "description": "Actions that the management system should take in response to container lifecycle events. Cannot be updated.",
          "$ref": "#/definitions/v1.Lifecycle"
        },
        "livenessProbe": {
          "description": "Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
          "$ref": "#/definitions/v1.Probe"
        },
        "name": {
          "description": "Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.",
          "type": "string",
          "default": ""
        },
        "ports": {
          "description": "List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default \"0.0.0.0\" address inside a container will be accessible from the network. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.ContainerPort"
          },
          "x-kubernetes-list-map-keys": [
            "containerPort",
            "protocol"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "containerPort",
          "x-kubernetes-patch-strategy": "merge"
        },
        "readinessProbe": {
          "description": "Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
          "$ref": "#/definitions/v1.Probe"
        },
        "resources": {
          "description": "Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
          "default": {},
          "$ref": "#/definitions/v1.ResourceRequirements"
        },
        "script": {
          "description": "Script is the contents of an executable file to execute.\n\nIf Script is not empty, the Step cannot have an Command or Args.",
          "type": "string"
        },
        "securityContext": {
          "description": "SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/",
          "$ref": "#/definitions/v1.SecurityContext"
        },
        "startupProbe": {
          "description": "StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
          "$ref": "#/definitions/v1.Probe"
        },
        "stdin": {
          "description": "Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.",
          "type": "boolean"
        },
        "stdinOnce": {
          "description": "Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false",
          "type": "boolean"
        },
        "terminationMessagePath": {
          "description": "Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.",
          "type": "string"
        },
        "terminationMessagePolicy": {
          "description": "Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.",
          "type": "string"
        },
        "tty": {
          "description": "Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.",
          "type": "boolean"
        },
        "volumeDevices": {
          "description": "volumeDevices is the list of block devices to be used by the container.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.VolumeDevice"
          },
          "x-kubernetes-list-type": "atomic",
          "x-kubernetes-patch-merge-key": "devicePath",
          "x-kubernetes-patch-strategy": "merge"
        },
        "volumeMounts": {
          "description": "Pod volumes to mount into the container's filesystem. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.VolumeMount"
          },
          "x-kubernetes-list-type": "atomic",
          "x-kubernetes-patch-merge-key": "mountPath",
          "x-kubernetes-patch-strategy": "merge"
        },
        "workingDir": {
          "description": "Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.",
          "type": "string"
        },
        "workspaces": {
          "description": "This is an alpha field. You must set the \"enable-api-fields\" feature flag to \"alpha\" for this field to be supported.\n\nWorkspaces is a list of workspaces from the Task that this Sidecar wants exclusive access to. Adding a workspace to this list means that any other Step or Sidecar that does not also request this Workspace will not have access to it.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.WorkspaceUsage"
          },
          "x-kubernetes-list-type": "atomic"
        }
      }
    },
    "v1.Step": {
      "description": "Step runs a subcomponent of a Task",
      "type": "object",
      "required": [
        "name"
      ],
      "properties": {
        "args": {
          "description": "Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "command": {
          "description": "Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "env": {
          "description": "List of environment variables to set in the container. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.EnvVar"
          },
          "x-kubernetes-list-type": "atomic",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "envFrom": {
          "description": "List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.EnvFromSource"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "image": {
          "description": "Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.",
          "type": "string"
        },
        "imagePullPolicy": {
          "description": "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images",
          "type": "string"
        },
        "name": {
          "description": "Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.",
          "type": "string",
          "default": ""
        },
        "onError": {
          "description": "OnError defines the exiting behavior of a container on error can be set to [ continue | stopAndFail ] stopAndFail indicates exit the taskRun if the container exits with non-zero exit code continue indicates continue executing the rest of the steps irrespective of the container exit code",
          "type": "string"
        },
        "resources": {
          "description": "Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
          "default": {},
          "$ref": "#/definitions/v1.ResourceRequirements"
        },
        "script": {
          "description": "Script is the contents of an executable file to execute.\n\nIf Script is not empty, the Step cannot have an Command and the Args will be passed to the Script.",
          "type": "string"
        },
        "securityContext": {
          "description": "SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/",
          "$ref": "#/definitions/v1.SecurityContext"
        },
        "timeout": {
          "description": "Timeout is the time after which the step times out. Defaults to never. Refer to Go's ParseDuration documentation for expected format: https://golang.org/pkg/time/#ParseDuration",
          "$ref": "#/definitions/v1.Duration"
        },
        "volumeDevices": {
          "description": "volumeDevices is the list of block devices to be used by the container.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.VolumeDevice"
          },
          "x-kubernetes-list-type": "atomic",
          "x-kubernetes-patch-merge-key": "devicePath",
          "x-kubernetes-patch-strategy": "merge"
        },
        "volumeMounts": {
          "description": "Pod volumes to mount into the container's filesystem. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.VolumeMount"
          },
          "x-kubernetes-list-type": "atomic",
          "x-kubernetes-patch-merge-key": "mountPath",
          "x-kubernetes-patch-strategy": "merge"
        },
        "workingDir": {
          "description": "Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.",
          "type": "string"
        },
        "workspaces": {
          "description": "This is an alpha field. You must set the \"enable-api-fields\" feature flag to \"alpha\" for this field to be supported.\n\nWorkspaces is a list of workspaces from the Task that this Step wants exclusive access to. Adding a workspace to this list means that any other Step or Sidecar that does not also request this Workspace will not have access to it.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.WorkspaceUsage"
          },
          "x-kubernetes-list-type": "atomic"
        }
      }
    },
    "v1.StepTemplate": {
      "description": "StepTemplate is a template for a Step",
      "type": "object",
      "properties": {
        "args": {
          "description": "Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "command": {
          "description": "Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "env": {
          "description": "List of environment variables to set in the container. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.EnvVar"
          },
          "x-kubernetes-list-type": "atomic",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "envFrom": {
          "description": "List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.EnvFromSource"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "image": {
          "description": "Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.",
          "type": "string"
        },
        "imagePullPolicy": {
          "description": "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images",
          "type": "string"
        },
        "resources": {
          "description": "Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
          "default": {},
          "$ref": "#/definitions/v1.ResourceRequirements"
        },
        "securityContext": {
          "description": "SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/",
          "$ref": "#/definitions/v1.SecurityContext"
        },
        "volumeDevices": {
          "description": "volumeDevices is the list of block devices to be used by the container.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.VolumeDevice"
          },
          "x-kubernetes-list-type": "atomic",
          "x-kubernetes-patch-merge-key": "devicePath",
          "x-kubernetes-patch-strategy": "merge"
        },
        "volumeMounts": {
          "description": "Pod volumes to mount into the container's filesystem. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.VolumeMount"
          },
          "x-kubernetes-list-type": "atomic",
          "x-kubernetes-patch-merge-key": "mountPath",
          "x-kubernetes-patch-strategy": "merge"
        },
        "workingDir": {
          "description": "Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.",
          "type": "string"
        }
      }
    },
    "v1.Task": {
      "description": "Task represents a collection of sequential steps that are run as part of a Pipeline using a set of inputs and producing a set of outputs. Tasks execute when TaskRuns are created that provide the input parameters and resources and output resources the Task requires.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec holds the desired state of the Task from the client",
          "default": {},
          "$ref": "#/definitions/v1.TaskSpec"
        }
      }
    },
    "v1.TaskList": {
      "description": "TaskList contains a list of Task",
      "type": "object",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Task"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ListMeta"
        }
      }
    },
    "v1.TaskResult": {
      "description": "TaskResult used to describe the results of a task",
      "type": "object",
      "required": [
        "name"
      ],
      "properties": {
        "description": {
          "description": "Description is a human-readable description of the result",
          "type": "string"
        },
        "name": {
          "description": "Name the given name",
          "type": "string",
          "default": ""
        },
        "properties": {
          "description": "Properties is the JSON Schema properties to support key-value pairs results.",
          "type": "object",
          "additionalProperties": {
            "default": {},
            "$ref": "#/definitions/v1.PropertySpec"
          }
        },
        "type": {
          "description": "Type is the user-specified type of the result. The possible type is currently \"string\" and will support \"array\" in following work.",
          "type": "string"
        }
      }
    },
    "v1.TaskRunResult": {
      "description": "TaskRunResult used to describe the results of a task",
      "type": "object",
      "required": [
        "name",
        "value"
      ],
      "properties": {
        "name": {
          "description": "Name the given name",
          "type": "string",
          "default": ""
        },
        "type": {
          "description": "Type is the user-specified type of the result. The possible type is currently \"string\" and will support \"array\" in following work.",
          "type": "string"
        },
        "value": {
          "description": "Value the given value of the result",
          "default": {},
          "$ref": "#/definitions/v1.ArrayOrString"
        }
      }
    },
    "v1.TaskSpec": {
      "description": "TaskSpec defines the desired state of Task.",
      "type": "object",
      "properties": {
        "description": {
          "description": "Description is a user-facing description of the task that may be used to populate a UI.",
          "type": "string"
        },
        "params": {
          "description": "Params is a list of input parameters required to run the task. Params must be supplied as inputs in TaskRuns unless they declare a default value.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.ParamSpec"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "results": {
          "description": "Results are values that this Task can output",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.TaskResult"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "sidecars": {
          "description": "Sidecars are run alongside the Task's step containers. They begin before the steps start and end after the steps complete.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Sidecar"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "stepTemplate": {
          "description": "StepTemplate can be used as the basis for all step containers within the Task, so that the steps inherit settings on the base container.",
          "$ref": "#/definitions/v1.StepTemplate"
        },
        "steps": {
          "description": "Steps are the steps of the build; each step is run sequentially with the source mounted into /workspace.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Step"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "volumes": {
          "description": "Volumes is a collection of volumes that are available to mount into the steps of the build.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Volume"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "workspaces": {
          "description": "Workspaces are the volumes that this Task requires.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.WorkspaceDeclaration"
          },
          "x-kubernetes-list-type": "atomic"
        }
      }
    },
    "v1.WorkspaceBinding": {
      "description": "WorkspaceBinding maps a Task's declared workspace to a Volume.",
      "type": "object",
      "required": [
        "name"
      ],
      "properties": {
        "configMap": {
          "description": "ConfigMap represents a configMap that should populate this workspace.",
          "$ref": "#/definitions/v1.ConfigMapVolumeSource"
        },
        "emptyDir": {
          "description": "EmptyDir represents a temporary directory that shares a Task's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir Either this OR PersistentVolumeClaim can be used.",
          "$ref": "#/definitions/v1.EmptyDirVolumeSource"
        },
        "name": {
          "description": "Name is the name of the workspace populated by the volume.",
          "type": "string",
          "default": ""
        },
        "persistentVolumeClaim": {
          "description": "PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. Either this OR EmptyDir can be used.",
          "$ref": "#/definitions/v1.PersistentVolumeClaimVolumeSource"
        },
        "secret": {
          "description": "Secret represents a secret that should populate this workspace.",
          "$ref": "#/definitions/v1.SecretVolumeSource"
        },
        "subPath": {
          "description": "SubPath is optionally a directory on the volume which should be used for this binding (i.e. the volume will be mounted at this sub directory).",
          "type": "string"
        },
        "volumeClaimTemplate": {
          "description": "VolumeClaimTemplate is a template for a claim that will be created in the same namespace. The PipelineRun controller is responsible for creating a unique claim for each instance of PipelineRun.",
          "$ref": "#/definitions/v1.PersistentVolumeClaim"
        }
      }
    },
    "v1.WorkspaceDeclaration": {
      "description": "WorkspaceDeclaration is a declaration of a volume that a Task requires.",
      "type": "object",
      "required": [
        "name"
      ],
      "properties": {
        "description": {
          "description": "Description is an optional human readable description of this volume.",
          "type": "string"
        },
        "mountPath": {
          "description": "MountPath overrides the directory that the volume will be made available at.",
          "type": "string"
        },
        "name": {
          "description": "Name is the name by which you can bind the volume at runtime.",
          "type": "string",
          "default": ""
        },
        "optional": {
          "description": "Optional marks a Workspace as not being required in TaskRuns. By default this field is false and so declared workspaces are required.",
          "type": "boolean"
        },
        "readOnly": {
          "description": "ReadOnly dictates whether a mounted volume is writable. By default this field is false and so mounted volumes are writable.",
          "type": "boolean"
        }
      }
    },
    "v1.WorkspacePipelineTaskBinding": {
      "description": "WorkspacePipelineTaskBinding describes how a workspace passed into the pipeline should be mapped to a task's declared workspace.",
      "type": "object",
      "required": [
        "name"
      ],
      "properties": {
        "name": {
          "description": "Name is the name of the workspace as declared by the task",
          "type": "string",
          "default": ""
        },
        "subPath": {
          "description": "SubPath is optionally a directory on the volume which should be used for this binding (i.e. the volume will be mounted at this sub directory).",
          "type": "string"
        },
        "workspace": {
          "description": "Workspace is the name of the workspace declared by the pipeline",
          "type": "string"
        }
      }
    },
    "v1.WorkspaceUsage": {
      "description": "WorkspaceUsage is used by a Step or Sidecar to declare that it wants isolated access to a Workspace defined in a Task.",
      "type": "object",
      "required": [
        "name",
        "mountPath"
      ],
      "properties": {
        "mountPath": {
          "description": "MountPath is the path that the workspace should be mounted to inside the Step or Sidecar, overriding any MountPath specified in the Task's WorkspaceDeclaration.",
          "type": "string",
          "default": ""
        },
        "name": {
          "description": "Name is the name of the workspace this Step or Sidecar wants access to.",
          "type": "string",
          "default": ""
        }
      }
    }
  }
}
